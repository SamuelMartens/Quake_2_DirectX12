PassProperties
{
PassInput : Static
PassVertAttr: VertexIn
}

State
{
ColorTarget  : GBuffer_Position, GBuffer_Albedo, GBuffer_Normals
DepthTarget  : DEPTH_BACK_BUFFER
Viewport	 : 0.0, 0.0, 1.0, 1.0
BlendEnabled : false
Topology	 : Triangle
}

RootSignature
{
RootFlags (ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
CBV(b0),
DescriptorTable(SRV(t0, numDescriptors = 1)),
DescriptorTable(Sampler(s0))
}

PrePass
{
	ClearDepth(1.0)
}

// Attributes

struct VertexIn
{
	float4 Pos : POSITION;
	float4 Normal : NORMAL; 
	float2 Tex : TEXCOORD;
}


struct VertexOut
{
	float4 Pos : SV_POSITION;
	float4 Normal: NORMAL;
	float4 WorldPos : POSITION;
	float2 Tex : TEXCOORD;
}

struct PixelOut
{
	float4 Position :	SV_Target0;
	float4 Albedo :		SV_Target1;
	float2 Normal :		SV_Target2;
}

// Resources 

[Global, PerPass]
cbuffer cbPerPass : register(b0)
{
    float4x4 gViewProj;
    float4 gCameraYaw;
    float4 gCameraPitch;
    float4 gCameraRoll;
    float4 gCameraOrigin;
}


[Global, PerObject]
Texture2D gDiffuseMap : register(t0)

[Global, PerPass]
SamplerState gSamLinearWrap : register(s0)



// Shaders

Type : VS 
External : cbPerPass, VertexIn, VertexOut
<[
VertexOut main(VertexIn vIn)
{
	VertexOut vOut;
	// Funny enought, by default matrices are packed as column major.
	vOut.Pos = mul(gViewProj, vIn.Pos);

	vOut.Normal = vIn.Normal;
	vOut.WorldPos = vIn.Pos;
	vOut.Tex = vIn.Tex;

	return vOut;
}
]>

Type : PS 
External : gDiffuseMap, gSamLinearWrap, VertexOut, PixelOut
<[
PixelOut main(VertexOut vOut) : SV_Target
{
	float4 color = gDiffuseMap.Sample(gSamLinearWrap, vOut.Tex);
    
	if (color.a == 0)
    {
        discard;
    }
	
	PixelOut output;
	
	output.Albedo = color;
	output.Normal =  vOut.Normal.xy;
	output.Position = vOut.WorldPos;
	
    return output;
}
]>