PassProperties
{
PassInput : Debug
PassVertAttr: VertexIn
}

State
{
ColorTarget  : BACK_BUFFER
DepthTarget  : BACK_BUFFER
Viewport	 : 0.0, 0.0, 1.0, 1.0
BlendEnabled : false
Topology	 : Triangle
}

RootSignature
{
RootFlags (ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
CBV(b0),
CBV(b1),
DescriptorTable(SRV(t0, numDescriptors = 1))
}

// Attributes

struct VertexIn
{
	float4 Pos : POSITION;
}


struct VertexOut
{
	float4 Pos : SV_POSITION;
	float4 LocalPos : POSITION;
}

// Resources  
[Global, PerPass]
StructuredBuffer<float4> sbDiffuseProbes : register(t0)

[Global, PerPass]
cbuffer cbPerPass : register(b0)
{
    float4x4 gViewProj;
    float4 gCameraYaw;
    float4 gCameraPitch;
    float4 gCameraRoll;
    float4 gCameraOrigin;
}

[Local, PerObject]
cbuffer cbPerObject_Local : register(b1)
{
	float4 gCenter;
	int gProbeIndex;
}


// Shaders

Type : VS 
External : cbPerPass, cbPerObject_Local, VertexIn, VertexOut
<[
VertexOut main(VertexIn vIn)
{
	VertexOut vOut;
	// Funny enought, by default matrices are packed as column major.
	vOut.Pos = mul(gViewProj, vIn.Pos);
	vOut.LocalPos =  vIn.Pos - gCenter; 
	
	return vOut;
}
]>

Type : PS 
External : VertexOut, sbDiffuseProbes, cbPerObject_Local
<[

#define INVALID_INDEX -1
#define SH_VECTOR_SIZE 9

float4 ReconstructRadianceFromSf(float4 dir)
{
	float shCoeff[SH_VECTOR_SIZE];
	
	// Band 0
	shCoeff[0] = 0.282095f;

	// Band 1
	shCoeff[1] = -0.488603f * dir.y;
	shCoeff[2] = 0.488603f * dir.z;
	shCoeff[3] = -0.488603f * dir.x;

	// Band 2
	shCoeff[4] = 1.092548f * dir.x * dir.y;
	shCoeff[5] = -1.092548f * dir.y * dir.z;
	shCoeff[6] = 0.315392f * (3.0f * dir.z * dir.z - 1.0f);
	shCoeff[7] = -1.092548f * dir.x * dir.z;
	shCoeff[8] = 0.546274f * (dir.x * dir.x - dir.y * dir.y);
	
	float4 rad = float4(0.0, 0.0, 0.0, 0.0);
	
	
	for (int i = 0; i < SH_VECTOR_SIZE; ++i)
	{
		const int shProbeCoeffIndex = gProbeIndex * SH_VECTOR_SIZE + i;
		
		rad += sbDiffuseProbes[shProbeCoeffIndex] * shCoeff[i];
	}
	
	return rad;
}

float4 main(VertexOut vOut) : SV_Target
{
	float4 dirFromCenter = float4(normalize(vOut.LocalPos.xyz) * 0.5 + 0.5, 1.0);
	float4 color = dirFromCenter;
	
	
	if (gProbeIndex != INVALID_INDEX)
	{
		color = ReconstructRadianceFromSf(dirFromCenter);
	}
	
    return color;
}
]>