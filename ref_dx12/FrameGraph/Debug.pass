PassProperties
{
PassInput : Debug
PassVertAttr: VertexIn
}

State
{
ColorTarget  : COLOR_BACK_BUFFER
DepthTarget  : DEPTH_BACK_BUFFER
Viewport	 : 0.0, 0.0, 1.0, 1.0
BlendEnabled : false
Topology	 : Triangle
}


RootSignature
{
RootFlags (ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
CBV(b0, space = 0),
CBV(b0, space = 1),
CBV(b0, space = 3),
DescriptorTable(SRV(t0, numDescriptors = 1, space = 0))
}

// -== Register space convention ==-
//	0 - Global, PerPass
//	1 - Global, PerObject
//	2 - Local, PerPass
//	3 - Local, PerObject

// Attributes

struct VertexIn
{
	float4 Pos : POSITION;
}


struct VertexOut
{
	float4 Pos : SV_POSITION;
	float4 LocalPos : POSITION;
}

// Resources  
[Global, PerPass]
cbuffer cbPerPass : register(b0, space0)
{
    float4x4 gViewProj;
    float4 gCameraYaw;
    float4 gCameraPitch;
    float4 gCameraRoll;
    float4 gCameraOrigin;
}

[Global, PerObject]
cbuffer cbPerObject_Global : register(b0, space1)
{
	int gDebugObjectType;
}

[Local, PerObject]
cbuffer cbPerObject_Local : register(b0, space3)
{
	// Probes debug info
	float4 gCenter;
	int gProbeIndex;
}

[Global, PerPass]
StructuredBuffer<float4> sbDiffuseProbes : register(t0, space0)

// Shaders

Type : VS 
External : cbPerPass, cbPerObject_Local, cbPerObject_Global, VertexIn, VertexOut
<[


@include "Debug.passh"


VertexOut main(VertexIn vIn)
{
	VertexOut vOut;
	// Funny enought, by default matrices are packed as column major.
	vOut.Pos = mul(gViewProj, vIn.Pos);
	
	if (gDebugObjectType == DEBUG_OBJECT_LIGHT_PROBE)
	{
		vOut.LocalPos =  vIn.Pos - gCenter; 
	}
	else
	{
		vOut.LocalPos = float4(0.0, 0.0, 0.0, 0.0);
	}

	return vOut;
}
]>

Type : PS 
External : VertexOut, sbDiffuseProbes, cbPerObject_Global, cbPerObject_Local
<[

@include "Debug.passh"
@include "Constants.passh"
@include "SHUtils.passh"



float4 main(VertexOut vOut) : SV_Target
{
	if (gDebugObjectType != DEBUG_OBJECT_LIGHT_PROBE)
	{
		discard;
	}

	float4 color = float4(0.0, 0.0, 0.0, 1.0);
	
	float4 dirFromCenter = float4(normalize(vOut.LocalPos.xyz) * 0.5 + 0.5, 1.0);
	color = dirFromCenter;
		
	if (gProbeIndex != INVALID_INDEX)
	{
		float4 sampleDir = float4(normalize(vOut.LocalPos.xyz), 0.0);
		color = ReconstructRadianceFromSH(sampleDir, gProbeIndex);
	}

    return color;
}
]>