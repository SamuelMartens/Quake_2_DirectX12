PassProperties
{
PassInput : PostProcess
PassThreadGroups: 64, 48, 1
}

State
{
}

RootSignature
{
RootFlags (ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
CBV(b0, space = 0),
CBV(b1, space = 0),
DescriptorTable(SRV(t4, numDescriptors = 2, space = 0)),
DescriptorTable(UAV(u2, numDescriptors = 2, space = 0)),
DescriptorTable(SRV(t0, numDescriptors = 3, space = 2)),
DescriptorTable(UAV(u0, numDescriptors = 1, space = 2))
}

// -== Register space convention ==-
//	0 - Global, PerPass
//	1 - Global, PerObject
//	2 - Local, PerPass
//	3 - Local, PerObject

// Structs
struct GPULight
{
	float4x4 worldTransform;
	float4 colorAndIntensity;
	float2 extends;
	int type;
}

struct GPULightBoundingVolume
{
	float4 origin;
	float radius;
}

struct PerClusterLightIndexData
{
	int offset;
	int count;
}

[Global, PerPass]
cbuffer cbFrameData : register(b0, space0)
{
	float4x4 InvertedViewProj;
	float4x4 InvertedProj;
    float4x4 ViewProj;
	float4x4 View;
    float4 CameraYaw;
    float4 CameraPitch;
    float4 CameraRoll;
    float4 CameraOrigin;
	float CameraNear;
	float CameraFar;
	int ScreenWidth;
	int ScreenHeight;
	int LightListSize;
}

[Global, PerPass]
cbuffer cbTileData : register(b1, space0)
{
	int TileWidth;
	int TileHeight;
	int NumFrustumSlices;
	int ClusterListSize;
}

[Global, PerPass]
StructuredBuffer<GPULightBoundingVolume> LightBoundingVolumes : register(t4, space0)

[Global, PerPass]
StructuredBuffer<GPULight> LightsList : register(t5, space0)

[Global, PerPass]
RWStructuredBuffer<int> ClusteredLightingIndexList : register(u2, space0)

[Global, PerPass]
RWStructuredBuffer<PerClusterLightIndexData> PerClusterLightIndexDataList : register(u3, space0)

// --- Local res
[Local, PerPass, Bind: GBuffer_Albedo]
Texture2D GBuffer_Albedo : register(t0, space2)

[Local, PerPass, Bind: GBuffer_Normals]
Texture2D GBuffer_Normals : register(t1, space2)

[Local, PerPass, Bind: GBuffer_Position]
Texture2D GBuffer_Position : register (t2, space2)

[Local, PerPass, Bind: DirectLightBuffer]
RWTexture2D<float4> DirectLightBuffer : register(u0, space2)

Type : CS
External : GPULight, LightsList, ClusteredLightingIndexList, PerClusterLightIndexData, PerClusterLightIndexDataList, GBuffer_Albedo, 
	GBuffer_Normals, GBuffer_Position, DirectLightBuffer, cbTileData, cbFrameData, GPULightBoundingVolume, LightBoundingVolumes
<[

#include "Debug.passh"
#include "Constants.passh"
#include "ClusteredLighting.passh"

#define ENABLE_POINT_LIGHTS 1
#define ENABLE_AREA_LIGHTS 1

float ComputAttenuationWindowedFunction(float dist, float distMax)
{
	return pow(max(0.0f, 1.0f - pow(dist / distMax, 4)), 2);
}

float ComputeDistanceAttenuation(float dist, float dist0, float distMax)
{
	float attenuation = 0.0f;

	if (dist <= dist0)
	{
		// Treat dist0 as distance to surface. If we measure light closer than that distance
		// we are basically inside light source, so just return 1.0
		attenuation = 1.0f;
	}
	else if (dist < distMax)
	{
		// Real-Time Rendering (4th Edition), page 113
		const float windowedFunctionValue = ComputAttenuationWindowedFunction(dist, distMax);

		// Real-Time Rendering (4th Edition), page 111
		const float distanceFalloff = pow(dist0 / dist, 2);

		attenuation = windowedFunctionValue * distanceFalloff;
	}
	
	return attenuation;
}

// Perfomed in world coordinate system
float ComputeRectangleSolidAngle(float3 surfacePoint, float3 p0, float3 p1, float3 p2, float3 p3)
{
	const float3 v0 = p0 - surfacePoint;
	const float3 v1 = p1 - surfacePoint;
	const float3 v2 = p2 - surfacePoint;
	const float3 v3 = p3 - surfacePoint;
	
	const float3 n0 = normalize(cross(v0, v1));
	const float3 n1 = normalize(cross(v1, v2));
	const float3 n2 = normalize(cross(v2, v3));
	const float3 n3 = normalize(cross(v3, v0));
	
	const float g0 = acos(dot(-n0, n1));
	const float g1 = acos(dot(-n1, n2));
	const float g2 = acos(dot(-n2, n3));
	const float g3 = acos(dot(-n3, n0));
	
	return g0 + g1 + g2 + g3 - 2 * M_PI;
} 

void ComputeAreaLighting(GPULight light, float4 worldPosition, float4 normal, float4 albedo, float maxDist, out float3 diffuse)
{
	const float4 lightNormal = mul(light.worldTransform, float4(0.0f, 0.0f, 1.0f, 0.0f));
	const float4 lightPosition = float4(light.worldTransform[0][3], 
		light.worldTransform[1][3],
		light.worldTransform[2][3], 
		1.0f);
	
	diffuse = float3(0.0f, 0.0f, 0.0f);
	
	// Ideally it should be 0, but because of problems with floating point math
	// I need to bump it up a bit, to avoid artifacts
	const float lightIsFacingSurfaceThreshold = 0.001f;
	const float3 lightToSurface = worldPosition.xyz - lightPosition.xyz;
	
	// Ignore points behind the light
	if (dot(lightToSurface, lightNormal.xyz) > lightIsFacingSurfaceThreshold )
	{
		// Find points describing light rectangle
		const float4 p0 = mul(light.worldTransform, float4(-light.extends.x / 2.0f, -light.extends.y / 2.0f, 0.0f, 1.0f));
		const float4 p1 = mul(light.worldTransform, float4(-light.extends.x / 2.0f, light.extends.y / 2.0f, 0.0f, 1.0f));
		const float4 p2 = mul(light.worldTransform, float4(light.extends.x / 2.0f, light.extends.y / 2.0f, 0.0f, 1.0f));
		const float4 p3 = mul(light.worldTransform, float4(light.extends.x / 2.0f, -light.extends.y / 2.0f, 0.0f, 1.0f));
		
		const float attenuationWindowedFunctionValue = ComputAttenuationWindowedFunction(length(lightToSurface), maxDist);
		
		const float solidAngle = ComputeRectangleSolidAngle(worldPosition.xyz, p0.xyz, p1.xyz, p2.xyz, p3.xyz);

		diffuse = solidAngle * 0.2f * (
			saturate(dot(normalize(p0.xyz - worldPosition.xyz), normal.xyz)) +
			saturate(dot(normalize(p1.xyz - worldPosition.xyz), normal.xyz)) + 
			saturate(dot(normalize(p2.xyz - worldPosition.xyz), normal.xyz)) + 
			saturate(dot(normalize(p3.xyz - worldPosition.xyz), normal.xyz)) + 
			saturate(dot(normalize(-lightToSurface), normal.xyz))) * albedo.xyz *
			light.colorAndIntensity.xyz * light.colorAndIntensity.w * attenuationWindowedFunctionValue;

		
	}
}

void ComputePointLighting(GPULight light, float4 worldPosition, float4 normal, float4 albedo, float maxDist, out float3 diffuse)
{
	const float3 lightPosition = float3(light.worldTransform[0][3], 
		light.worldTransform[1][3],
		light.worldTransform[2][3]);
		
	float3 pointToLight = lightPosition - worldPosition.xyz;
	
	const float pointToLightDist = length(pointToLight);
	const float attenuation = ComputeDistanceAttenuation(pointToLightDist, light.extends.x, maxDist);
	
	pointToLight = normalize(pointToLight);
	
	diffuse = attenuation * max(dot(pointToLight, normal.xyz), 0.0f) * light.colorAndIntensity.xyz * light.colorAndIntensity.w * albedo.xyz;
}

[numthreads(16, 16, 1)]
void main(int3 dispatchThreadID : SV_DispatchThreadID)
{
	// Fetch G Buffers data
	const float4 worldPosition = GBuffer_Position[dispatchThreadID.xy];
	const float4 normal = GBuffer_Normals.Load(int3(dispatchThreadID.xy, 0));
	const float4 albedo = GBuffer_Albedo.Load(int3(dispatchThreadID.xy, 0));
	
	// Find pixel cluster index
	const float4 viewPositon = mul(View, worldPosition);
	const int clusterIndex = GetClusterIndex(dispatchThreadID.xy, viewPositon.z);
	
	const PerClusterLightIndexData perClusterData = PerClusterLightIndexDataList[clusterIndex];
	
	if (perClusterData.count == 0)
	{
		return;
	}
	
	float3 diffuse = float3(0.0f, 0.0f, 0.0f);
	
	// Iterate over lights and calculate contribution
	for (int lightIndex = 0; lightIndex < perClusterData.count; ++lightIndex)
	{
		const int lightListIndex = ClusteredLightingIndexList[lightIndex + perClusterData.offset];
		GPULight light = LightsList[lightListIndex];
		GPULightBoundingVolume boundingVolume = LightBoundingVolumes[lightListIndex];
		
		const float maxDist = boundingVolume.radius;
		
		float3 lightDiffuse = float3(0.0f, 0.0f, 0.0f);

		if (light.type == POINT_LIGHT)
		{
#if (ENABLE_POINT_LIGHTS)
			ComputePointLighting(light, worldPosition, normal, albedo, maxDist, lightDiffuse);
#endif
		}
		else if (light.type == AREA_LIGHT)
		{
#if (ENABLE_AREA_LIGHTS)
			ComputeAreaLighting(light, worldPosition, normal, albedo, maxDist, lightDiffuse);		
#endif
		}
		
		diffuse += lightDiffuse;
	}
	
	DirectLightBuffer[dispatchThreadID.xy] =  float4(diffuse, 1.0f);
}

]>