PassProperties
{
PassInput : PostProcess
PassThreadGroups: 32, 24, 1
}

State
{
}

RootSignature
{
RootFlags (ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
CBV(b0, space = 0),
CBV(b1, space = 0),
DescriptorTable(SRV(t1, numDescriptors = 1, space = 0)),
DescriptorTable(SRV(t2, numDescriptors = 1, space = 2),
UAV(u0, numDescriptors = 1, space = 2))
}


// -== Register space convention ==-
//	0 - Global, PerPass
//	1 - Global, PerObject
//	2 - Local, PerPass
//	3 - Local, PerObject


// Structs
struct AABB
{
	float4 Min;
	float4 Max;
}

// --- Global ---

[Global, PerPass]
cbuffer cbFrameData : register(b0, space0)
{
    float4x4 InvertedViewProj;
	int ScreenWidth;
	int ScreenHeight;
}

[Global, PerPass]
cbuffer cbClusterAABBParameters : register(b1, space0)
{
	int ClusterAABBsSize;
}

[Global, PerPass]
StructuredBuffer<AABB> ClusterAABBs : register(t1, space0)

// --- Local ---
[Local, PerPass, Bind: ClusterClassification]
RWTexture2D<int> ClusterClassification : register(u0, space2)

//#DEBUG make this global
[Local, PerPass]
Texture2D DepthBuffer : register (t2, space2)

Type : CS
External : AABB, ClusterAABBs, cbClusterAABBParameters, ClusterClassification, DepthBuffer, cbFrameData
<[

float3 GetWorldPosFromDepthAndScreenCoord(int2 screenCoord, float depth)
{
	// NOTE: This doesn't account for the screen offset
	const float4 ndcPixelCoords = float4(
	((float)screenCoord.x / ScreenWidth) * 2.0f - 1.0f, 
	((float)screenCoord.y / ScreenHeight) * -2.0f + 1.0f,
	depth, 
	1.0f);

	float4 worldCoord = mul(InvertedViewProj, ndcPixelCoords);
	worldCoord = worldCoord / worldCoord.w;

	return worldCoord.xyz;
}


[numthreads(32, 32, 1)]
void main(int3 dispatchThreadID : SV_DispatchThreadID)
{
	if (ClusterAABBsSize == 0)
	{
		return;
	}

	int clusterIndex = -1;
	
	const float depth = DepthBuffer.Load(int3(dispatchThreadID.xy, 0)).x;
	float3 pixelPosition = GetWorldPosFromDepthAndScreenCoord(dispatchThreadID.xy, depth);
	
	// Iterate over each AABB
	for (int i = 0; i < ClusterAABBsSize; ++i)
	{
		AABB clusterAABB = ClusterAABBs.Load(i);
		
		float3 diagonal = normalize(clusterAABB.Max.xyz - clusterAABB.Min.xyz);
		
		// Extend a bit to avoid floating point errors during testing
		const float epsilon = 0.005f;
		clusterAABB.Min.xyz = clusterAABB.Min.xyz - diagonal * epsilon;
		clusterAABB.Max.xyz = clusterAABB.Max.xyz + diagonal * epsilon;
		
		
		// If inside AABB
		if (all(pixelPosition >= clusterAABB.Min.xyz) &&
			all(pixelPosition <= clusterAABB.Max.xyz))
		{
			clusterIndex = i;
			break;
		}
	}
	
	ClusterClassification[dispatchThreadID.xy] = clusterIndex; 
}

]>
